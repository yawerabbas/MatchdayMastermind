# -*- coding: utf-8 -*-
"""UCL_Final_Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nOr3U2GFm6xAoVpYKTRPsriwkyjtuAlL
"""

# Commented out IPython magic to ensure Python compatibility.
import requests
from bs4 import BeautifulSoup
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
# %matplotlib inline


sns.set(style="ticks")

# Function to scrape player performance data
def scrape_player_performance(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')

    # Find the player performance table
    player_table = soup.find('table', {'id': 'stats_standard_8'})

    # Extract player performance data
    # player_performance = []
    # headers = []
    # if player_table:
    #     header_row = player_table.find('thead').find_all('tr')[-1]
    #     headers = [header.text.strip() for header in header_row.find_all('th')]
    #     rows = player_table.find_all('tbody')[1].find_all('tr')
    #     for row in rows:
    #         data = [cell.text.strip() for cell in row.find_all('td')]
    #         player_performance.append(data)
    player_performance = []
    headers = []
    if player_table:
        header_row = player_table.find('thead').find_all('tr')[-1]
        headers = [header.text.strip() for header in header_row.find_all('th')]
        rows = player_table.find('tbody').find_all('tr')
        for row in rows:
            data = [cell.text.strip() for cell in row.find_all('td')]
            player_name = row.find('th').text.strip()
            player_performance.append([player_name] + data)

    return player_performance, headers

# URLs for player performance data
man_city_url = 'https://fbref.com/en/squads/b8fd03ef/2022-2023/c8/Manchester-City-Stats-Champions-League'
inter_milan_url = 'https://fbref.com/en/squads/d609edc0/2022-2023/c8/Internazionale-Stats-Champions-League'

# Scrape player performance data for Manchester City and Inter Milan
man_city_performance, man_city_headers = scrape_player_performance(man_city_url)
inter_milan_performance, inter_milan_headers = scrape_player_performance(inter_milan_url)

# Create DataFrames for player performance data
man_city_df = pd.DataFrame(man_city_performance, columns=man_city_headers)
inter_milan_df = pd.DataFrame(inter_milan_performance, columns=inter_milan_headers)

man_city_df.columns

# Replace empty strings with 0
man_city_df.replace('', 0, inplace=True)
inter_milan_df.replace('', 0, inplace=True)

# Convert relevant columns to numeric and sum the values for Manchester City
man_city_sum = man_city_df[['Gls', 'Ast']].apply(pd.to_numeric, errors='coerce').sum()

# Convert relevant columns to numeric and sum the values for Inter Milan
inter_milan_sum = inter_milan_df[['Gls', 'Ast']].apply(pd.to_numeric, errors='coerce').sum()

# Create DataFrames for summed values
man_city_sum_df = pd.DataFrame(man_city_sum).transpose()
inter_milan_sum_df = pd.DataFrame(inter_milan_sum).transpose()

# Concatenate the DataFrames
combined_df = pd.concat([man_city_sum_df, inter_milan_sum_df])

# Plot the stacked bar plot
ax = combined_df[['Gls', 'Ast']].plot(kind='bar', stacked=True, figsize=(10, 6))
ax.set_xticklabels(['Manchester City', 'Inter Milan'], rotation=0)
plt.xlabel('Team')
plt.ylabel('Goals and Assists')
plt.title('Goals and Assists Comparison: Manchester City vs Inter Milan')
plt.legend(['Goals', 'Assists'])

plt.show()

corr = man_city_df[['Gls', 'Ast', 'G+A', 'G-PK', 'PK', 'PKatt', 'CrdY', 'CrdR', 'xG', 'npxG', 'xAG', 'npxG+xAG']].apply(pd.to_numeric, errors='coerce').corr()
plt.figure(figsize=(16, 8))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title('Correlation between Performance')

corr = inter_milan_df[['Gls', 'Ast', 'G+A', 'G-PK', 'PK', 'PKatt', 'CrdY', 'CrdR', 'xG', 'npxG', 'xAG', 'npxG+xAG']].apply(pd.to_numeric, errors='coerce').corr()
plt.figure(figsize=(16, 8))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title('Correlation between Performance')

# Replace empty strings with 0
man_city_df.replace('', 0, inplace=True)
inter_milan_df.replace('', 0, inplace=True)

#Initalizing Inter and Man Score.
man_city_score = 0
inter_milan_score = 0

man_city_pp_score = man_city_df[['Gls','Ast', 'G+A', 'G-PK', 'PK', 'PKatt', 'CrdY', 'CrdR', 'xG', 'npxG','xAG', 'npxG+xAG']].apply(pd.to_numeric, errors='coerce').sum().sum()
inter_milan_pp_score = inter_milan_df[['Gls','Ast', 'G+A', 'G-PK', 'PK', 'PKatt', 'CrdY', 'CrdR', 'xG', 'npxG','xAG', 'npxG+xAG']].apply(pd.to_numeric, errors='coerce').sum().sum()

# Scoring
if man_city_pp_score > inter_milan_pp_score:
  man_city_score+=1
elif inter_milan_pp_score > man_city_pp_score :
  inter_milan_score+=1
else :
  man_city_score +=1
  inter_milan_score +=1

def get_head_to_head_results(url, team):
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')

    # Find the table rows for each team in head-to-head results
    rows = soup.find_all('tr', {'class': 'highlight home'})

    team_wins = 0
    team_draws = 0
    team_losses = 0

    for row in rows:
        columns = row.find_all('td')
        home_team = columns[2].text.strip()
        away_team = columns[4].text.strip()
        result = columns[3].text.strip()

        if home_team == team:
            if result == 'W':
                team_wins += 1
            elif result == 'D':
                team_draws += 1
            elif result == 'L':
                team_losses += 1
        elif away_team == team:
            if result == 'W':
                team_losses += 1
            elif result == 'D':
                team_draws += 1
            elif result == 'L':
                team_wins += 1

    return {
        'Wins': team_wins,
        'Draws': team_draws,
        'Losses': team_losses
    }

def evaluate_past_records(past_records, head_to_head_url):
    # Evaluate past records and head-to-head results and assign scores
    # You can define your own evaluation algorithm based on specific criteria
    scores = {}

    # Evaluate past records
    for team, records in past_records.items():
        record_score = 0

        # Assign scores based on wins, draws, and losses
        record_score += records['Wins'] * 3
        record_score += records['Draws'] * 1
        record_score += records['Losses'] * 0
        # Add more evaluation criteria for past records

        # Get head-to-head results
        h2h_results = get_head_to_head_results(head_to_head_url, team)
        h2h_score = h2h_results['Wins'] * 3 + h2h_results['Draws'] * 1 + h2h_results['Losses'] * 0
        # Add more evaluation criteria for head-to-head results

        scores[team] = record_score + h2h_score

    return scores

# Past records
past_records = {
    'Manchester City': {
        'Wins': 10,
        'Draws': 5,
        'Losses': 3
        # Add more relevant information
    },
    'Inter Milan': {
        'Wins': 8,
        'Draws': 6,
        'Losses': 4
        # Add more relevant information
    }
}

# Extract the teams and their respective records
teams = list(past_records.keys())
wins = [past_records[team]['Wins'] for team in teams]
draws = [past_records[team]['Draws'] for team in teams]
losses = [past_records[team]['Losses'] for team in teams]

# Set the positions of the bars on the x-axis
positions = range(len(teams))

# Plotting the bar chart
plt.bar(positions, wins, label='Wins', color='green')
plt.bar(positions, draws, bottom=wins, label='Draws', color='yellow')
plt.bar(positions, losses, bottom=[wins[i] + draws[i] for i in range(len(wins))], label='Losses', color='red')

# Customize the plot
plt.xlabel('Teams')
plt.ylabel('Count')
plt.title('Past Records')
plt.xticks(positions, teams)
plt.legend()

# Show the plot
plt.show()

# URL for head-to-head results
head_to_head_url = 'https://www.uefa.com/uefachampionsleague/history/h2h/52919/50138/'

# Evaluate past records and head-to-head results
record_scores = evaluate_past_records(past_records, head_to_head_url)

# Scoring
if record_scores['Manchester City'] > record_scores['Inter Milan']:
    man_city_score+=1
elif record_scores['Manchester City'] < record_scores['Inter Milan'] :
    inter_milan_score +=1
else :
  inter_milan_score +=1
  man_city_score+=1

def evaluate_team_strategies(team_strategies):
    # Evaluate team strategies and assign scores
    # You can define your own evaluation algorithm based on specific criteria
    scores = {}

    # Evaluate team strategies
    for team, strategy in team_strategies.items():
        strategy_score = 0

        # Assign scores based on formation
        if strategy['Formation'] == '4-3-3':
            strategy_score += 3
        elif strategy['Formation'] == '3-5-2':
            strategy_score += 5
       
        # Assign scores based on playing style
        if strategy['PlayingStyle'] == 'Possession-based':
            strategy_score += 4
        elif strategy['PlayingStyle'] == 'Defensive-counterattack':
            strategy_score += 3
        

        scores[team] = strategy_score

    return scores

# Team strategies
team_strategies = {
    'Manchester City': {
        'Formation': '4-3-3',
        'PlayingStyle': 'Possession-based'
      
    },
    'Inter Milan': {
        'Formation': '3-5-2',
        'PlayingStyle': 'Defensive-counterattack'
      
    }
}

# Evalute Team Strategies
strategy_scores = evaluate_team_strategies(team_strategies)

# Scoring
if strategy_scores['Manchester City'] > strategy_scores['Inter Milan']:
    man_city_score+=1
elif strategy_scores['Manchester City'] < strategy_scores['Inter Milan'] :
    inter_milan_score +=1
else :
  inter_milan_score +=1
  man_city_score+=1

# Making the Final Prediction
if man_city_score > inter_milan_score:
    print("Manchester City is the better team ")
elif inter_milan_score > man_city_score:
    print("Inter Milan is the better team")
else:
    print("Both teams have similar performance.")